#####################
What is Junit
####################

-> JUnit is a Java testing framework that helps you write and run unit tests ‚Äî small, focused tests that verify the correctness of individual pieces of code (like a method or class) in isolation/integeration testing.

-> It‚Äôs lightweight, fast, and integrates easily with build tools like Maven and Gradle.

-> Versions: Latest major version is JUnit 5, which is more flexible and modular than JUnit 4.

-> Assertions: Offers methods check expected outcome with actual outcome

Note: we should perform -ve and +ve testing both

######################
What is JaCoCo
######################

-> JaCoCo tells you how much of your code was actually executed when you ran your tests.
-> It works as plugin with Junit
-> Often required for CI/CD quality gates (e.g., "Fail build if coverage < 80%").

######################
Why use Mockito?
######################
-> Mockito is a Java mocking framework used in unit testing to create fake objects
-> In real applications, a class often depends on other components ‚Äî like databases, web services, or other classes.
-> When testing, you don‚Äôt want to call the real database or real API. Instead, you create mocks that simulate their behavior


#########################################
üìù JUnit vs Mockito Annotations
#########################################

| **JUnit Annotations**  | **One-liner Definition**                 | **Mockito Annotations**                 | **One-liner Definition**                                |
| ---------------------- | ---------------------------------------- | --------------------------------------- | ------------------------------------------------------- |
| **@Test**              | Marks a method as a test case.           | **@Mock**                               | Creates a fake/mock instance of a class/interface.      |
| **@BeforeEach**        | Runs before each test method (setup).    | **@Spy**                                | Creates a spy (real object but methods can be stubbed). |
| **@AfterEach**         | Runs after each test method (cleanup).   | **@InjectMocks**                        | Injects mock/spies automatically into the tested class. |
| **@BeforeAll**         | Runs once before all test methods.       | **@Captor**                             | Captures method arguments for verification.             |
| **@AfterAll**          | Runs once after all test methods.        | **@ExtendWith(MockitoExtension.class)** | Enables Mockito annotations in JUnit 5.                 |
| **@Disabled**          | Disables/ignores a test method or class. | ‚Äì                                       | ‚Äì                                                       |
| **@DisplayName**       | Provides a custom name for the test.     | ‚Äì                                       | ‚Äì                                                       |
| **@RepeatedTest**      | Runs the same test multiple times.       | ‚Äì                                       | ‚Äì                                                       |
| **@ParameterizedTest** | Runs test with different input values.   | ‚Äì                                       | ‚Äì                                                       |
| **@Tag**               | Groups/tests filtering with tags.        | ‚Äì                                       | ‚Äì                                                       |
| **@Nested**            | Defines nested test classes.             | ‚Äì                                       | ‚Äì                                                       |


üü¢ Spring Boot Testing Annotations

| **Annotation**                 | **Belongs To**                                            | **One-liner Definition**                                                                      |
| ------------------------------ | --------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **@SpringBootTest**            | `org.springframework.boot.test.context`                   | Loads the full Spring ApplicationContext for integration testing.                             |
| **@DataJpaTest**               | `org.springframework.boot.test.autoconfigure.orm.jpa`     | Loads only JPA components (Entity, Repository) for testing database layer.                    |
| **@WebMvcTest**                | `org.springframework.boot.test.autoconfigure.web.servlet` | Loads only web layer (controllers, filters) without service/repository beans.                 |
| **@RestClientTest**            | `org.springframework.boot.test.autoconfigure.web.client`  | Loads only RestTemplate and related beans for REST client testing.                            |
| **@JsonTest**                  | `org.springframework.boot.test.autoconfigure.json`        | Loads only JSON-related components (e.g., Jackson) for testing serialization/deserialization. |
| **@JdbcTest**                  | `org.springframework.boot.test.autoconfigure.jdbc`        | Loads JDBC-related components for testing JDBC code.                                          |
| **@AutoConfigureMockMvc**      | `org.springframework.boot.test.autoconfigure.web.servlet` | Auto-configures MockMvc for testing controllers without starting a real server.               |
| **@AutoConfigureTestDatabase** | `org.springframework.boot.test.autoconfigure.jdbc`        | Replaces your DataSource with an embedded test database during testing.                       |


                            #################
                            Example 1
                            #################
package com.app.dto;

public class Calculator {

    public int add(int x,int y) {
        return x+y;
    }

    public int mul(int x,int y) {
        return x*y;
    }
}


package com.app;

import com.app.dto.Calculator;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class CalculatorTest {


    @Test
    public void testAdd(){
        Calculator calculator = new Calculator();
       int actual= calculator.add(10,20);
        int expected = 30;

        Assertions.assertEquals(expected,actual);
    }


    @Test
    public void testMul(){
        Calculator calculator = new Calculator();
        int actual= calculator.mul(5,6);
        int expected = 30;

        Assertions.assertEquals(expected,actual);
    }
}



Integrate Jacoco plugin
###########################

<plugin>
	<groupId>org.jacoco</groupId>
	<artifactId>jacoco-maven-plugin</artifactId>
	<version>0.8.11</version>
	<configuration>
		<excludes>
		<exclude>com/app/Unit**</exclude>
		</excludes>
	</configuration>
	<executions>
		<execution>
			<goals>
				<goal>prepare-agent</goal>
			</goals>
		</execution>
		<execution>
			<id>report</id>
			<phase>test</phase>
			<goals>
				<goal>report</goal>
			</goals>
		</execution>
	</executions>
</plugin>

Note: to see how much code tested open target -> site -> jacoco -> index.html (copy path and open in browser)


                                                  #################
                                                   Example 2
                                                  #################

-----------------------------------------
testing the UserController in isolation
----------------------------------------

‚úÖ Summary :
-> This is a Unit Test for UserController.
-> It checks behavior in isolation, using Mockito mocks.
-> Not an integration test because the full application context, repository, or DB are not loaded.
-> If you used @SpringBootTest (with real beans, configs, repo), that would become an Integration Test.

Explanation of code ?
----------------------

What is being tested?
-> You are testing the UserController in isolation.

How is it isolated?
-> The real UserService is not being used. Instead, you provide a mock (@Mock) of UserService. So the controller‚Äôs logic is tested without depending on database, repository, or Spring context.

what is Key signs this is Unit Test?
-> @ExtendWith(MockitoExtension.class) ‚Üí No Spring context is started.
-> Dependencies (UserService) are mocked.
-> Fast execution (just JUnit + Mockito).
-> Test verifies controller‚Äìservice interaction, not the whole system.


Note:
 Why we use verify()?
 In unit testing, verification ensures that your code:
    1.  Calls the right methods
    2.  With the right parameters
    3.  And the correct number of times


Defination of annotations:=

@ExtendWith(MockitoExtension.class) : 
-> Tells JUnit 5 to enable Mockito features for the test class.
-> Automatically initializes all @Mock and @InjectMocks fields before each test runs.
-> Replaces the need to manually call: MockitoAnnotations.openMocks(this);

@Mock :
-> Creates a mock object of the class or interface.

@InjectMocks :
-> Creates an instance of the class under test and injects the mocks into it automatically. / Make the real class, and give it all the fake objects where needed.


Entity :=> 

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private String name;
}



Controller :=>

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService service;

    public UserController(UserService service) {
        this.service = service;
    }


    @GetMapping("/{id}")
    public String getUserName(@PathVariable int id) {
        return service.getUserName(id);
    }
}



service :=>

@Service
public class UserService {

    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }
    
    public String getUserName(int id) {
        Optional<User> user = repository.findById(id);
        if (user.isPresent()) {
            return user.get().getName();
        } else {
            return "Unknown User";
        }
    }
}


repository :=>

public interface UserRepository extends JpaRepository<User,Integer> {
    Optional<User> findById(int id);
}



testController :=>

import com.app.controller.UserController;
import com.app.service.UserService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class UserControllerTest {

    // service dummy object created
    @Mock
    private UserService mockService;


    // done dependency injection constructor based
    @InjectMocks
    private UserController userController;
    

    @Test
    public void testGetUser_Found(){
        // Mock service call
        when(mockService.getUserName(1)).thenReturn("sahil");

        // Call controller method
        String result = userController.getUserName(1);

        // Assert result
        assertEquals("sahil", result);

        // Verify service interaction
        verify(mockService, times(1)).getUserName(1);
    }



    @Test
    void testGetUserName_NotFound() {
        when(mockService.getUserName(2)).thenReturn("Unknown User");

        String result = userController.getUserName(2);

        assertEquals("Unknown User", result);

        verify(mockService, times(1)).getUserName(2);
    }
}



Normal JUnit 5 test class without @ExtendWith annotations :

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class UserControllerTest {

    @Test
    void testGetUserName_Found() {
        // Create mock manually
        UserService mockService = mock(UserService.class);

        // Define behavior
        when(mockService.getUserName(1)).thenReturn("Alice");

        // Inject into controller manually
        UserController controller = new UserController(mockService);

        // Call method & assert
        assertEquals("Alice", controller.getUserName(1));

        // Verify interaction
        verify(mockService, times(1)).getUserName(1);
    }

    @Test
    void testGetUserName_NotFound() {
        // Create mock manually
        UserService mockService = mock(UserService.class);

        // Define behavior
        when(mockService.getUserName(2)).thenReturn("Unknown User");

        // Inject into controller manually
        UserController controller = new UserController(mockService);

        // Call method & assert
        assertEquals("Unknown User", controller.getUserName(2));

        // Verify interaction
        verify(mockService, times(1)).getUserName(2);
    }
}




                                                  #################
                                                   Example 3
                                                  #################

-----------------------------------------
testing the userService in isolation
----------------------------------------

Note: use same above code for user-service-test class


@ExtendWith(MockitoExtension.class)
public class UserServiceTest {

    @Mock
    private UserRepository repository;

    @InjectMocks
    private UserService service;

    @Test
    public void testGetUsername_Found(){
        // Arrange
        when(repository.findById(1)).thenReturn(Optional.of(new User(1,"sahil")));

        // Act
       String name= service.getUserName(1);

       // Assert
        assertEquals("sahil",name);

        // Verify that repository.findById() was called exactly once with argument 1
        verify(repository,times(1)).findById(1);
    }


    @Test
    public void testGetUsername_NotFound(){
     when(repository.findById(2)).thenReturn(Optional.empty());
     String name = service.getUserName(2);
     assertEquals("Unknown User",name);
        verify(repository,times(1)).findById(2);
    }
}





                                                  #################
                                                   Example 4
                                                  #################

------------------------------------------------------------
Testing RestControllers like real HTTP requests/responses.
------------------------------------------------------------



Difference between @WebMvcTest and @ExtendWith(MockitoExtension.class) :

| Feature / Aspect      | **@WebMvcTest**                                                                                                       | **@ExtendWith(MockitoExtension.class)**                                                 |
| --------------------- | --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **Purpose**           | Testing **Spring MVC controllers** (web layer).                                                                       | Testing **any class in isolation** (unit test).                                         |
| **Spring Context**    | Starts a **partial Spring context** (only web layer beans).                                                           | Does **not start Spring context** ‚Üí plain JUnit + Mockito.                              |
| **Scope**             | Loads controller, `@ControllerAdvice`, filters, JSON converters, etc.                                                 | Only loads your test class and mocks (fast).                                            |
| **Dependencies**      | You must use `@MockBean` for Service/Repository since they aren‚Äôt loaded.                                             | You use `@Mock` + `@InjectMocks` to create dependencies.                                |
| **What you can test** | - HTTP endpoints (`/users/1`)  <br> - Status codes (200, 404, 500) <br> - Response JSON/body <br> - Validation errors | - Method logic <br> - Business rules <br> - Interaction with dependencies (`verify()`). |
| **Speed**             | Slower (because it boots up Spring web layer).                                                                        | Faster (no Spring boot-up).                                                             |
| **Example Usage**     | `@WebMvcTest(UserController.class)` ‚Üí testing REST endpoints.                                                         | `@ExtendWith(MockitoExtension.class)` ‚Üí testing `UserService` methods.                  |



Note: 

What is MockMvc ?
-> MockMvc is a Spring class used for testing your controllers without actually starting a real HTTP server (like Tomcat).
-> it simulate HTTP requests (GET, POST, PUT, etc.) and check the response (status code, headers, JSON body).
-> Think of it like a fake Postman inside your JUnit test.


Application.properties Files :


spring.application.name=mvc_unit_test

spring.datasource.url=jdbc:mysql://localhost:3306/db1
spring.datasource.username=root
spring.datasource.password=test
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true



Entitiy class :

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private String name;
}


Controller class : 


@RestController
@RequestMapping("/users")
public class UserController {
    private final UserService service;

    public UserController(UserService service) { // constructor-based DI
        this.service = service;
    }

    @GetMapping("/{id}")
    public ResponseEntity<String> getUserName(@PathVariable int id) {
        String name = service.getUserName(id);
        if ("Unknown User".equals(name)) {
            return ResponseEntity.notFound().build();      // 404
        }
        return ResponseEntity.ok(name);                    // 200
    }

    @PostMapping
    public ResponseEntity<User> create(@RequestBody User user) {
        User created = service.createUser(user);
        return ResponseEntity.status(201).body(created);   // 201
    }

    @PutMapping("/{id}")
    public ResponseEntity<User> update(@PathVariable int id, @RequestBody User user) {
        Optional<User> updated = service.updateUser(id, user);
        return updated.map(ResponseEntity::ok)              // 200
                .orElseGet(() -> ResponseEntity.notFound().build()); // 404
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable int id) {
        boolean deleted = service.deleteUser(id);
        return deleted ? ResponseEntity.noContent().build() // 204
                : ResponseEntity.notFound().build(); // 404
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = service.findAllUsers();

        if (users.isEmpty()) {
            // Return HTTP 204 No Content
            return ResponseEntity.noContent().build();
        }

        // Return HTTP 200 OK with the list
        return ResponseEntity.ok(users);
    }
}



service class : 

@Service
public class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) { // constructor-based DI
        this.repository = repository;
    }

    public String getUserName(int id) {
        return repository.findById(id).map(User::getName).orElse("Unknown User");
    }

    public User createUser(User user) {
        return repository.save(user);
    }

    public Optional<User> updateUser(int id, User user) {
        return repository.findById(id).map(existing -> repository.save(new User(id, user.getName())));
    }

    public boolean deleteUser(int id) {
        if (repository.findById(id).isPresent()) {
            repository.deleteById(id);
            return true;
        }
        return false;
    }

    public List<User> findAllUsers() {
        return repository.findAll();
    }

}


Repository interface  :

public interface UserRepository extends JpaRepository<User,Integer> {
}


Now Test class for UserControllerWebMvcTest  : 

















